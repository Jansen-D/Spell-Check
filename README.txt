* The goal of this project was to load a text file (containing a dictionary) into a hash table in an efficient way in order to access the data more easily
* After loading the dictionary into a hash table, the user is prompted to enter a string. This string will be spell checked word by word to see if there are any errors. If a word is misspelled, all suggestions within an edit distance of two are suggested to the user. Each of these suggestions will be valid words in the dictionary given.
* The most difficult part of this project was coming up with suggestions for misspelled words. From what I could tell these edit functions are not commutative (meaning a swap then deletion may yield a different result than a deletion then a swap). To implement this, I had each edit function call every other possible edit function after doing its editing. However, the function will not run if the edit distance has already reached two.
* For my hash function I used a multiplication method. For each character in each word, I took the ascii value, multiplied it by a prime number less than the word size (w=64) of the machine. This result was modded by W which is 2^w. Finally, this result was divided by 2^w-p which is 2^5 =32. This all was added to the hash for each character, resulting in a hash function that used about 80.5% percent of the buckets. There is room for improvement here, but it fits the criteria!
* I feel that I could improve my function for finding suggestions as I may be going through a lot of duplicate suggestions. Possibly there is an algorithm such as Strassen√ïs which would allow me to use these duplicate suggestions to my advantage and shorten the time taken.
* Originally my findword() function consisted of nested loops which would traverse every node in the table which took far too long. By hashing each string I have to search for, I can enter the table using that key. When I enter the table at the right index, all we have to do is traverse the chain, which could even be empty. This cuts the search time of almost 500000 elements down to a fraction of a second.
